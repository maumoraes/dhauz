# -*- coding: utf-8 -*-
"""Teste Dhauz.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FxU2miViU_9mtiynUAzw35-R0vzb70sd

# Teste técnico Dhauz

Vamos iniciar autenticando as credenciais
"""

!pip install mysql-connector-python

!pip install boto3

import mysql.connector
import sys
import boto3
import os

ENDPOINT="dhauz-instance.cutloqirhpd7.us-east-1.rds.amazonaws.com"
PORT="3306"
USER="candidate_user"
REGION="us-east-1"
DBNAME="db_hiring_test"
pswrd = "D3@bGh664%$1VHv*"
os.environ['LIBMYSQL_ENABLE_CLEARTEXT_PLUGIN'] = '1'

#gets the credentials from .aws/credentials
session = boto3.Session()
client = session.client('rds', region_name=REGION)

"""# Análise inicial do banco de dados

Para começar, iremos realizar uma consulta incluindo todos os resultados
"""

try:
    conn =  mysql.connector.connect(host=ENDPOINT, user=USER, passwd=pswrd, port=PORT, database=DBNAME, ssl_ca='SSLCERTIFICATE')
    cur = conn.cursor()
    cur.execute("""SELECT *, REPLACE(TotalSent,',','') as Value FROM db_hiring_test.raw_transactions_table LIMIT 10""")
    query_results = cur.fetchall()
    field_names = print([i[0] for i in cur.description])
    for row in query_results:
      print(row)
except Exception as e:
    print("Database connection failed due to {}".format(e))

"""# Fase 1:

## Questão 1: 
 Começando com as consultas que respondem as questões levantadas

 Primeiramente pegamos as 5 primeiras carteiras que enviaram mais transações
"""

try:
    cur2 = conn.cursor()
    cur2.execute("""SELECT AddressOrigin, COUNT(AddressOrigin) FROM db_hiring_test.raw_transactions_table GROUP BY AddressOrigin ORDER BY COUNT(AddressOrigin) DESC LIMIT 5""")
    query_results2 = cur.fetchall()
    for row in query_results2:
      print(row)
except Exception as e:
    print("Database connection failed due to {}".format(e))

"""## Questão 2: Dias com maior incidência de transações


"""

try:
    cur3 = conn.cursor()
    cur3.execute("""SELECT DAYOFMONTH(SentDate) as Dia, COUNT(DAYOFMONTH(SentDate)) FROM db_hiring_test.raw_transactions_table GROUP BY Dia ORDER BY COUNT(Dia) DESC LIMIT 5""")
    query_results3 = cur.fetchall()
    for row in query_results3:
      print(row)
except Exception as e:
    print("Database connection failed due to {}".format(e))

"""## Questão 3: Dia da semana com maior incidência de transferências"""

try:
    cur4 = conn.cursor()
    cur4.execute("""SELECT DAYNAME(SentDate) as dia_da_semana, COUNT(DAYNAME(SentDate)) FROM db_hiring_test.raw_transactions_table GROUP BY dia_da_semana ORDER BY COUNT(dia_da_semana) DESC LIMIT 7""")
    query_results4 = cur.fetchall()
    for row in query_results4:
      print(row)
except Exception as e:
    print("Database connection failed due to {}".format(e))

"""## Questão 4: Transações suspeitas dentro dos dados

A priori iremos olhar para as transações que tiveram suas condições negadas, e desta forma analisar o que elas podem ter em comum
"""

try:
    cur5 = conn.cursor()
    cur5.execute("""SELECT * FROM db_hiring_test.raw_transactions_table WHERE Status = 'Denied' ORDER BY TotalSent DESC LIMIT 10""")
    query_results5 = cur.fetchall()
    for row in query_results5:
      print(row)
except Exception as e:
    print("Database connection failed due to {}".format(e))

"""Podemos reparar a incidência de transações duplicadas e também com datas coincidindo na casa dos segundos, sendo esse o motivo para elas terem seu status negado, sendo passível de investigação

## Questão 5:

Agora para a análise iremos realizar uma função que realiza o cálculo das carteiras
"""

try:
    lista = []
    cur6 = conn.cursor()
    cur6.execute("""WITH pagamentos as (SELECT AddressOrigin as Address, SUM(REPLACE(TotalSent,',','')) as Value FROM db_hiring_test.raw_transactions_table GROUP BY Address),
                    recebimentos as (SELECT AddressDestination as Address, SUM(REPLACE(TotalSent,',','')*-1) as Value FROM db_hiring_test.raw_transactions_table GROUP BY Address)
                    INSERT INTO pagamentos (Address, Value) VALUE(SELECT * FROM recebimentos);
                    SELECT Address, SUM(Value) FROM pagamentos GROUP BY Address""")
    query_results6 = cur.fetchall()
    for row in query_results6:
      print(row)
except Exception as e:
    print("Database connection failed due to {}".format(e))

"""# Fase 2:

Agora iremos reunir as informações das duas tabelas para podermos associar o custo de cada transação com a sua respectiva taxa
"""

try:
    cur7 = conn.cursor()
    cur7.execute("""SELECT * FROM db_hiring_test.raw_transactions_fee""")
    query_results7 = cur.fetchall()
    field_names = print([i[0] for i in cur7.description])
    for row in query_results7:
      print(row)
except Exception as e:
    print("Database connection failed due to {}".format(e))

"""Criando a tabela auxiliar para podermos realizar as análises"""

try: 
    cur8 = conn.cursor()
    cur8.execute("""WITH tabAux AS (SELECT * FROM db_hiring_test.raw_transactions_table t1 INNER JOIN db_hiring_test.raw_transactions_fee t2 ON REPLACE(t1.TotalSent,',','') <= t2.`range-end` AND REPLACE(t1.TotalSent,',','') >= t2.`range-start`) 
                    SELECT * FROM tabAux LIMIT 5""") 
    query_results8 = cur.fetchall()
    field_names = print([i[0] for i in cur8.description])
    for row in query_results8:
      print(row)
except Exception as e:
    print("Database connection failed due to {}".format(e))

"""Para realizar a verificação da fórmula, iremos exibir os valores das taxas das 5 primeiras transações"""

try:    
    cur9 = conn.cursor()
    cur9.execute("""WITH tabAux AS (SELECT * FROM db_hiring_test.raw_transactions_table t1 INNER JOIN db_hiring_test.raw_transactions_fee t2 ON REPLACE(t1.TotalSent,',','') <= t2.`range-end` AND REPLACE(t1.TotalSent,',','') >= t2.`range-start`) 
                    SELECT IdTransaction, AddressOrigin, REPLACE(TotalSent,',','') *`fee-percentage`/100 AS TaxPaid FROM tabAux LIMIT 5""")
    query_results9 = cur.fetchall()
    field_names = print([i[0] for i in cur9.description])
    for row in query_results9:
      print(row)
except Exception as e:
    print("Database connection failed due to {}".format(e))

"""Agora realizaremos a agregação dos valores para notarmos quais são os 5 primeiras carteiras que mais pagaram taxa no mês de Janeiro de 2021"""

try:
    cur10 = conn.cursor()
    cur10.execute("""WITH tabAux AS (SELECT * FROM db_hiring_test.raw_transactions_table t1 INNER JOIN db_hiring_test.raw_transactions_fee t2 ON REPLACE(t1.TotalSent,',','') <= t2.`range-end` AND REPLACE(t1.TotalSent,',','') >= t2.`range-start`) 
                    SELECT AddressOrigin, SUM(REPLACE(TotalSent,',','') *`fee-percentage`)/100 AS TaxPaid FROM tabAux WHERE MONTH(SentDate) = 01 AND YEAR(SentDate) = 2021 GROUP BY AddressOrigin ORDER BY TaxPaid DESC LIMIT 5""") 
    query_results10 = cur.fetchall()
    field_names = print([i[0] for i in cur10.description])
    for row in query_results10:
      print(row)
except Exception as e:
    print("Database connection failed due to {}".format(e))

"""Agora realizaremos o mesmo procedimento para Fevereiro de 2021"""

try:
    cur11 = conn.cursor()
    cur11.execute("""WITH tabAux AS (SELECT * FROM db_hiring_test.raw_transactions_table t1 INNER JOIN db_hiring_test.raw_transactions_fee t2 ON REPLACE(t1.TotalSent,',','') <= t2.`range-end` AND REPLACE(t1.TotalSent,',','') >= t2.`range-start`) 
                    SELECT AddressOrigin, SUM(REPLACE(TotalSent,',','') *`fee-percentage`)/100 AS TaxPaid FROM tabAux WHERE MONTH(SentDate) = 02 AND YEAR(SentDate) = 2021 GROUP BY AddressOrigin ORDER BY TaxPaid DESC LIMIT 5""") 
    query_results11 = cur.fetchall()
    field_names = print([i[0] for i in cur11.description])
    for row in query_results11:
      print(row)
except Exception as e:
    print("Database connection failed due to {}".format(e))

"""Podemos também realizar uma querie para pegarmos o valor da maior taxa e o ID da transação associado a ela"""

try:
    cur12 = conn.cursor()
    cur12.execute("""WITH tabAux AS (SELECT * FROM db_hiring_test.raw_transactions_table t1 INNER JOIN db_hiring_test.raw_transactions_fee t2 ON REPLACE(t1.TotalSent,',','') <= t2.`range-end` AND REPLACE(t1.TotalSent,',','') >= t2.`range-start`) 
                    SELECT *, REPLACE(TotalSent,',','')*`fee-percentage`/100 AS TaxPaid FROM tabAux ORDER BY TaxPaid DESC LIMIT 1""") 
    query_results12 = cur.fetchall()
    field_names = print([i[0] for i in cur12.description])
    for row in query_results12:
      print(row)
except Exception as e:
    print("Database connection failed due to {}".format(e))

"""Na última questão da Fase 2 iremos pegar a média de todas as transações usando a fórmula AVG()"""

try:
    cur13 = conn.cursor()
    cur13.execute("""WITH tabAux AS (SELECT * FROM db_hiring_test.raw_transactions_table t1 INNER JOIN db_hiring_test.raw_transactions_fee t2 ON REPLACE(t1.TotalSent,',','') <= t2.`range-end` AND REPLACE(t1.TotalSent,',','') >= t2.`range-start`) 
                    SELECT ROUND(AVG(REPLACE(TotalSent,',','')*`fee-percentage`/100),2) AS AvgTaxPaid FROM tabAux LIMIT 1""") 
    query_results13 = cur.fetchall()
    field_names = print([i[0] for i in cur13.description])
    for row in query_results13:
      print(row)
except Exception as e:
    print("Database connection failed due to {}".format(e))

"""# Fase 3:

Para criação da estrutura da automação dentro do Google Cloud Platform, para rodar os scripts podemos utilizar as ferramentas:

*   Google IAM
*   Google Cloud Function
*   Google Cloud Scheduler

Primeiramente podemos criar uma **service account** e posteriormente uma **cloud function** contendo o código em Python que possui a função que cria, altera ou consulta o nosso banco de dados, como por exemplo uma das células acima. Durante a criação, podemos colocar como **trigger** uma requisição HTTP, adicionando a nossa service account como um dos usuários com permissão para acessá-la.

Logo depois da criação da cloud function, devemos criar um **Cloud Scheduler**, lá definiremos a frequência e também o endereço HTTP que o scheduler irá realizar a requisição. É necessário incluir o permissionamento juntamente com a service account previamente criada. 

É possível tornar a Cloud Function pública, evitando a primeira etapa do IAM, porém não se trata da melhor prática, pois qualquer pessoa da web poderia realizar a requisição.
"""